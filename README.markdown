HtmlBuffer
==========

The HtmlBuffer is a struct that embeds a bytes.Buffer and decorates it with a set of methods for generating HTML 5 documents.

It supports all the elements listed [here](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/HTML5_element_list "HTML5 element list")

Stability
---------

The API is new and should be considered unstable. Expect changes.

Installation
------------

    go get github.com/peterskeide/htmlbuffer

Normal (non-void) elements
--------------------------

For most non-void element the HtmlBuffer API exposes two methods; a normal method and an "underscore" method.
For the `body` element that would be:

* `func (b *HtmlBuffer) Body(attrs htmlbuffer.Attrs, innerHtml func())`
* `func (b *HtmlBuffer) Body_(innerHtml func())`

The "underscore" method makes the API a little less noisy when you need to generate elements without attributes (you don't have to pass a nil value for attrs everywhere).

The `title`, `option` and `textarea` elements are a bit different. They only support text, and cannot have child elements:

* `func (b *HtmlBuffer) Title(attrs Attrs, formatStr string, a ...interface{})`
* `func (b *HtmlBuffer) Title_(formatStr string, a ...interface{})`

Void elements
-------------

For every void element the HtmlBuffer exposes the same two methods, but they do not accept a function for writing nested content. Using `link` as an example:

* `func (b *HtmlBuffer) Link(attrs htmlbuffer.Attrs)`
* `func (b *HtmlBuffer) Link_()`

Attributes
----------

Element attributes are generated by passing an instance of htmlbuffer.Attrs to the element methods (this is a type alias for `map[string]string`).

    buffer.Link(htmlbuffer.Attrs{"href": "http://www.example.com", "rel": "stylesheet", "type": "text/css"})

Text
-----

To write element text to the buffer, use the `Text` method: `buffer.Text("lorem ipsum")`. The `Text` method escapes HTML. If you don't want to
escape HTML content, use the `RawText` method: `buffer.RawText("<div>foo</div>")`. Both methods support format verbs via fmt.Sprintf.

* `func (b *HtmlBuffer) Text(formatStr string, a ...interface{})`
* `func (b *HtmlBuffer) RawText(formatStr string, a ...interface{})`

Child elements
--------------

Elements can have child elements by passing a closure to the element method:

    buffer.Body(htmlbuffer.Attrs{"class": "demo"}, func() {
        buffer.Div_(func() {
            buffer.Text("lorem ipsum")
        })
    })

Shortcut methods
----------------

The HtmlBuffer has some methods to make it simpler to define attributes and text/raw text. Assuming the HtmlBuffer variable is named `b`:

    b.Div(b.Attrs("id=%s, class=test widget", id), func() {
        b.Button(b.Attrs("type=button"), b.TextF("Click me!"))
    })

Available shortcut methods are:

* `func (b *HtmlBuffer) TextF(formatStr string, a ...interface{}) func()`         // For writing text
* `func (b *HtmlBuffer) RawTextF(formatStr string, a ...interface{}) func()`      // For writing unescaped text
* `func (b *HtmlBuffer) Attrs(formatStringAttrs string, a ...interface{}) Attrs`  // For intializing htmlbuffer.Attrs with attribute values

The `Attrs` method expects a string with a comma separated list of attributes, where the attribute name and value is separated by `=`. Example:

    b.Attrs("id=content, class=first second")

For marker attributes such as `checked`, just use the name of the attribute without a value (and without `=`).

The attributes string can contain format verbs as defined in the [fmt package](http://golang.org/pkg/fmt/ "fmt package documentation").

Input methods
-------------

For every input type there are two methods that let you write an input element of that type to the buffer without explicitly declaring the type attribute. Using type `email` as an example:

* `func (b *HtmlBuffer) EmailInput(attrs htmlbuffer.Attrs)`
* `func (b *HtmlBuffer) EmailInput_()`

Non-standard elements
---------------------

The HtmlBuffer exposes two lower level methods for writing elements. These can be used to write elements that are not part of the HTML spec, such
as AngularJS directives.

The methods are:

* `func (b *HtmlBuffer) WriteNormalElement(tagName string, attrs Attrs, innerHtml func())` // For writing elements with start and end tags
* `func (b *HtmlBuffer) WriteVoidElement(tagName string, attrs Attrs)`                     // For writing void elements (start tag only)

Using with the `net/http` package
---------------------------------

The HtmlBuffer has a method for writing its content to http.ResponseWriter:

    func (b *HtmlBuffer) WriteToResponse(res http.ResponseWriter)

"Extras"
--------

Finally, there are some methods that make common things a bit more concise:

* `func (b *HtmlBuffer) Html5(attrs Attrs, innerHtml func())`  // Writes a HTML5 doctype declaration and a html element
* `func (b *HtmlBuffer) Html5_(innerHtml func())`              // Same as above, but without attributes
* `func (b *HtmlBuffer) StylesheetLink(href string)`           // Write a link to an external stylesheet
* `func (b *HtmlBuffer) ExternalScript(src string)`            // Write a script element referencing an external javascript asset

Example
-------

    func DemoHandler(res http.ResponseWriter, req *http.Request) {

        b := htmlbuffer.NewHtmlBuffer()

        b.Html5(b.Attrs("lang=en"), func() {
            b.Head_(func() {
                b.Title_("HtmlBuffer Demo")
                b.StylesheetLink("assets/demo.css")
            })

            b.Body_(func() {
                b.Div(b.Attrs("class=main"), func() {
                    b.Text("Hello ")
                    b.Span_(b.TextF("World!"))
                })

                b.Form(b.Attrs("id=name-form, action=process"), func() {
                    b.TextInput(b.Attrs("name=firstname"))
                    b.SubmitInput(b.Attrs("value=Send name"))
                })
            })
        })

        b.WriteToResponse(res)
    }

License (MIT)
-------------

Copyright (C) 2013 Peter Skeide

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
