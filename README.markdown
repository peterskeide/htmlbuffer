HtmlWriter
==========

The HtmlWriter is a struct that embeds an io.Writer and decorates it with a set of methods for generating HTML 5 documents.

It supports all the elements listed [here](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/HTML5_element_list "HTML5 element list")

Stability
---------

The API is new and should be considered unstable. Expect changes.

Installation
------------

    go get github.com/peterskeide/htmlwriter

Normal (non-void) elements
--------------------------

For most non-void element the HtmlWriter API exposes two methods; a normal method and an "underscore" method.
For the `body` element that would be:

* `func (w *HtmlWriter) Body(attrs htmlwriter.Attrs, innerHtml func())`
* `func (w *HtmlWriter) Body_(innerHtml func())`

The "underscore" method makes the API a little less noisy when you need to generate elements without attributes (you don't have to pass a nil value for attrs everywhere).

The `title`, `option` and `textarea` elements are a bit different. They only support text, and cannot have child elements:

* `func (w *HtmlWriter) Title(attrs Attrs, formatStr string, a ...interface{})`
* `func (w *HtmlWriter) Title_(formatStr string, a ...interface{})`

Void elements
-------------

For every void element the HtmlWriter exposes the same two methods, but they do not accept a function for writing nested content. Using `link` as an example:

* `func (w *HtmlWriter) Link(attrs htmlwriter.Attrs)`
* `func (w *HtmlWriter) Link_()`

Attributes
----------

Element attributes are generated by passing an instance of htmlwriter.Attrs to the element methods (this is a type alias for `map[string]string`).

    writer.Link(htmlwriter.Attrs{"href": "http://www.example.com", "rel": "stylesheet", "type": "text/css"})

Text
-----

To write element text to the Writer, use the `Text` method: `writer.Text("lorem ipsum")`. The `Text` method escapes HTML. If you don't want to
escape HTML content, use the `RawText` method: `writer.RawText("<div>foo</div>")`. Both methods support format verbs via fmt.Sprintf.

* `func (w *HtmlWriter) Text(formatStr string, a ...interface{})`
* `func (w *HtmlWriter) RawText(formatStr string, a ...interface{})`

Child elements
--------------

Elements can have child elements by passing a closure to the element method:

    writer.Body(htmlwriter.Attrs{"class": "demo"}, func() {
        writer.Div_(func() {
            writer.Text("lorem ipsum")
        })
    })

Shortcut methods
----------------

The HtmlWriter has some methods to make it simpler to define attributes and text/raw text. Assuming the HtmlWriter variable is named `w`:

    w.Div(w.Attrs("id=%s, class=test widget", id), func() {
        w.Button(w.Attrs("type=button"), w.TextF("Click me!"))
    })

Available shortcut methods are:

* `func (w *HtmlWriter) TextF(formatStr string, a ...interface{}) func()`         // For writing text
* `func (w *HtmlWriter) RawTextF(formatStr string, a ...interface{}) func()`      // For writing unescaped text
* `func (w *HtmlWriter) Attrs(formatStringAttrs string, a ...interface{}) Attrs`  // For intializing htmlwriter.Attrs with attribute values

The `Attrs` method expects a string with a comma separated list of attributes, where the attribute name and value is separated by `=`. Example:

    w.Attrs("id=content, class=first second")

For marker attributes such as `checked`, just use the name of the attribute without a value (and without `=`).

The attributes string can contain format verbs as defined in the [fmt package](http://golang.org/pkg/fmt/ "fmt package documentation").

Input methods
-------------

For every input type there are two methods that let you write an input element of that type to the Writer without explicitly declaring the type attribute. Using type `email` as an example:

* `func (w *HtmlWriter) EmailInput(attrs htmlwriter.Attrs)`
* `func (w *HtmlWriter) EmailInput_()`

Non-standard elements
---------------------

The HtmlWriter exposes two lower level methods for writing elements. These can be used to write elements that are not part of the HTML spec, such
as AngularJS directives.

The methods are:

* `func (w *HtmlWriter) WriteNormalElement(tagName string, attrs Attrs, innerHtml func())` // For writing elements with start and end tags
* `func (w *HtmlWriter) WriteVoidElement(tagName string, attrs Attrs)`                     // For writing void elements (start tag only)

"Extras"
--------

Finally, there are some methods that make common things a bit more concise:

* `func (w *HtmlWriter) Html5(attrs Attrs, innerHtml func())`  // Writes a HTML5 doctype declaration and a html element
* `func (w *HtmlWriter) Html5_(innerHtml func())`              // Same as above, but without attributes
* `func (w *HtmlWriter) StylesheetLink(href string)`           // Write a link to an external stylesheet
* `func (w *HtmlWriter) ExternalScript(src string)`            // Write a script element referencing an external javascript asset

Examples
--------

A basic example of writing static HTML directly to the ResponseWriter:

    func DemoHandler(res http.ResponseWriter, req *http.Request) {

        w := htmlwriter.NewHtmlWriter(res)

        w.Html5(w.Attrs("lang=en"), func() {
            w.Head_(func() {
                w.Title_("HtmlWriter Demo")
                w.StylesheetLink("assets/demo.css")
            })

            w.Body_(func() {
                w.Div(w.Attrs("class=main"), func() {
                    w.Text("Hello ")
                    w.Span_(w.TextF("World!"))
                })

                w.Form(w.Attrs("id=name-form, action=process"), func() {
                    w.TextInput(w.Attrs("name=firstname"))
                    w.SubmitInput(w.Attrs("value=Send name"))
                })
            })
        })
    }

Building a simple templating system on top of the HtmlWriter (full program):

    package main

    import (
        "github.com/peterskeide/htmlwriter"
        "log"
        "net/http"
    )

    func main() {
        http.HandleFunc("/person", PersonHandler)
        http.HandleFunc("/persons", PersonListHandler)

        log.Println("Starting server on port 8000")
        log.Fatal(http.ListenAndServe(":8000", nil))
    }

    func PersonHandler(res http.ResponseWriter, req *http.Request) {
        pt := NewPersonTemplates(res)

        pt.title = "Person"
        pt.person = Person{"John Doe", 30}

        pt.Layout(pt.PersonTemplate)
    }

    func PersonListHandler(res http.ResponseWriter, req *http.Request) {
        pt := NewPersonTemplates(res)

        pt.title = "Person List"
        pt.persons = []Person{Person{"John Doe", 30}, Person{"Jane Doe", 28}}

        pt.Layout(pt.PersonListTemplate)
    }

    type Person struct {
        Name string
        Age  int
    }

    type PersonTemplates struct {
        *htmlwriter.HtmlWriter
        title   string
        person  Person
        persons []Person
    }

    func NewPersonTemplates(res http.ResponseWriter) (pt *PersonTemplates) {
        pt = new(PersonTemplates)
        pt.HtmlWriter = htmlwriter.NewHtmlWriter(res)
        return
    }

    func (pt *PersonTemplates) Layout(template func()) {
        pt.Html5_(func() {
            pt.Head_(func() {
                pt.Title_(pt.title)
            })

            pt.Body_(template)
        })
    }

    func (pt *PersonTemplates) PersonTemplate() {
        pt.Div(pt.Attrs("class=person"), func() {
            pt.Em_(pt.TextF(pt.person.Name))
            pt.Text(", age %d", pt.person.Age)
        })
    }

    func (pt *PersonTemplates) PersonListTemplate() {
        pt.Ul_(func() {
            for _, p := range pt.persons {
                pt.Li_(pt.TextF("%s (%d)", p.Name, p.Age))
            }
        })
    }

By following the approach of the example above, it is very easy to build reusable widgets, form controls etc.

License (MIT)
-------------

Copyright (C) 2013 Peter Skeide

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
